// Copyright 2021 Nathan (Blaise) Bruer.  All rights reserved.

syntax = "proto3";

package com.github.allada.turbo_cache.remote_execution;

import "build/bazel/remote/execution/v2/remote_execution.proto";
import "google/protobuf/empty.proto";

/// This API describes how schedulers communicate with Worker nodes.
///
/// When a worker node comes online it must be pre-configured with the
/// endpoint of the scheduler it will register with. Once the worker
/// connects to the scheduler it must send a `RegisterSupportedProperties`
/// command to the scheduler. The scheduler will then use this information
/// to determine which jobs the worker can process.
service WorkerApi {
    /// Registers this worker and informs the scheduler what properties
    /// this worker supports. The response must be listened on the client
    /// side for updates from the server.
    rpc ConnectWorker(SupportedProperties) returns (stream UpdateForWorker);

    /// Message used to let the scheduler know that it is still alive as
    /// well as check to see if the scheduler is still alive. The scheduler
    /// may close the connection if the worker has not sent any messages
    /// after some amount of time (configured in the scheduler's
    /// configuration).
    rpc KeepAlive(google.protobuf.Empty) returns (google.protobuf.Empty);

    /// Informs the scheduler that the service is going offline and
    /// should stop issuing any new actions on this worker.
    ///
    /// The worker may stay connected even after sending this command
    /// and may even send an `ExecuteResult` after sending this command.
    /// It is up to the scheduler implementation to decide how to handle
    /// this case.
    ///
    /// Any job that was running on this instance likely needs to be
    /// executed again, but up to the scheduler on how or when to handle
    /// this case.
    rpc GoingAway(google.protobuf.Empty) returns (google.protobuf.Empty);

    /// Informs the scheduler about the result of an execution request.
    rpc ExecutionResponse(ExecuteResult) returns (google.protobuf.Empty);
}

/// Represents the initial request sent to the scheduler informing the
/// scheduler about this worker's capabilities.
message SupportedProperties {
    /// The list of properties this worker can support. The exact
    /// implementation is driven by the configuration matrix between the
    /// worker and scheduler.
    ///
    /// The scheduler may reject this worker if any property keys that
    /// the scheduler is not configured to support, or may simply ignore
    /// the unsupported properties.
    ///
    /// The details on how to use this property can be found here:
    /// https://github.com/allada/turbo-cache/blob/c91f61edf182f2b64451fd48a5e63fa506a43aae/config/cas_server.rs
    repeated build.bazel.remote.execution.v2.Platform.Property properties = 1;
    reserved 2; // NextId.
}

/// Represents the result of an execution.
message ExecuteResult {
    /// Result of the execution. See `build.bazel.remote.execution.v2.ExecuteResponse`
    /// for details.
    build.bazel.remote.execution.v2.ExecuteResponse execute_response = 1;
    reserved 2; // NextId.
}

/// Result sent back from the server when a node connects.
message ConnectionResult {
    /// The internal ID given to the newly connected node.
    string worker_id = 1;
    reserved 2; // NextId.
}

/// Communication from the scheduler to the worker.
message UpdateForWorker {
    oneof update {
        /// This will be sent only as the first item in the stream after the node
        /// has connected.
        ConnectionResult connection_result = 1;

        /// Message used to let the worker know that it is still alive as well
        /// as check to see if the worker is still alive. The worker
        /// may close the connection if the scheduler has not sent any messages
        /// after some amount of time (configured in the scheduler's
        /// configuration).
        google.protobuf.Empty keep_alive = 2;

        /// Informs the worker about some work it should begin performing the
        /// requested action.
        StartExecute start_action = 3;
    }
    reserved 4; // NextId.
}

message StartExecute {
    build.bazel.remote.execution.v2.ExecuteRequest execute_request = 1;
    reserved 2; // NextId.
}
