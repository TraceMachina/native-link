import type { Root } from "mdast";
import { remark } from "remark";
import remarkParse from "remark-parse";

export function preProcessMarkdown(markdown: string): string {
  const processed = removeValeAndGitCliffComments(markdown);
  const lines = processed.split("\n");

  const processedLines = processLines(lines);

  return processedLines.join("\n");
}

function removeValeAndGitCliffComments(markdown: string): string {
  return markdown
    .replace(/<!--\s*vale\s+(on|off)\s*-->/g, "")
    .replace(/<!--\s*generated by git-cliff\s*-->/g, "");
}

export function parseMarkdown(markdown: string): Root {
  return remark().use(remarkParse).parse(markdown) as Root;
}

function processLines(lines: string[]) {
  const processedLines = [];
  let mermaidBlock = false;
  let codeBlock = false;
  let listBlock = false;

  for (const line of lines) {
    if (processMermaidBlock(line, mermaidBlock, processedLines)) {
      mermaidBlock = !mermaidBlock;
      continue;
    }

    if (processCodeBlock(line, codeBlock, mermaidBlock, processedLines)) {
      codeBlock = !codeBlock;
      continue;
    }

    listBlock = processListBlock(line, listBlock, processedLines);
    if (listBlock) {
      continue;
    }

    if (processSpecialLine(line, processedLines)) {
      continue;
    }

    processedLines.push(escapeHtml(line));
  }

  // Ensure any unclosed list is closed
  closeList(listBlock, processedLines);

  return processedLines;
}

function processMermaidBlock(
  line: string,
  mermaidBlock: boolean,
  processedLines: string[],
): boolean {
  if (isMermaidBlockStart(line)) {
    processedLines.push(line);
    return true;
  }

  if (mermaidBlock && isBlockEnd(line)) {
    processedLines.push(line);
    return true;
  }

  return false;
}

function processCodeBlock(
  line: string,
  codeBlock: boolean,
  mermaidBlock: boolean,
  processedLines: string[],
): boolean {
  if (isCodeBlock(line) && !mermaidBlock) {
    processedLines.push(line);
    return true;
  }

  if (codeBlock) {
    processedLines.push(line);
    return true;
  }

  return false;
}

function processListBlock(
  line: string,
  listBlock: boolean,
  processedLines: string[],
): boolean {
  let isListBlock = listBlock;

  if (/^\d+\.\s+\*\*(.+)\*\*:/.test(line)) {
    isListBlock = closeList(isListBlock, processedLines);
    processedLines.push(line);
    processedLines.push('<ul className="list-disc list-inside pl-4">');
    return true;
  }

  if (isListBlock && /^\s*-\s+(.+)/.test(line)) {
    processedLines.push(line.replace(/^\s*-\s+(.+)/, "<li>$1</li>"));
    return true;
  }

  return closeList(isListBlock, processedLines);
}

function processSpecialLine(line: string, processedLines: string[]): boolean {
  if (
    line.trim().startsWith(">") ||
    /^\[!(TIP|NOTE|WARNING|IMPORTANT|CAUTION)\]/.test(line)
  ) {
    processedLines.push(line);
    return true;
  }

  return false;
}

function isMermaidBlockStart(line: string): boolean {
  return line.trim().startsWith("```mermaid");
}

function isBlockEnd(line: string): boolean {
  return line.trim() === "```";
}

function isCodeBlock(line: string): boolean {
  return line.trim().startsWith("```");
}

function closeList(inList: boolean, processedLines: string[]): boolean {
  if (inList) {
    processedLines.push("</ul>");
    return false;
  }
  return inList;
}

function escapeHtml(line: string): string {
  const htmlTagPattern = /^[<\s][^>]*>/g;
  return htmlTagPattern.test(line)
    ? line
    : line.replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
